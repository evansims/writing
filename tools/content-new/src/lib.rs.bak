use anyhow::Result;
use common_config::load_config;
use common_fs::{create_dir_all, write_file};
use common_models::{Frontmatter, TopicConfig};
use std::path::PathBuf;

pub struct NewOptions {
    pub slug: Option<String>,
    pub topic: Option<String>,
    pub title: Option<String>,
    pub description: Option<String>,
    pub template: Option<String>,
    pub tags: Option<Vec<String>>,
    pub draft: Option<bool>,
}

/// Create new content
///
/// This function creates new content in the specified topic.
///
/// # Parameters
///
/// * `options` - New content options
///
/// # Returns
///
/// Returns the path to the created content
///
/// # Errors
///
/// Returns an error if the content cannot be created
pub fn create_content(options: &NewOptions) -> Result<PathBuf> {
    // Validate options
    let slug = options.slug.as_ref().ok_or_else(|| anyhow::anyhow!("Content slug is required"))?;
    let topic = options.topic.as_ref().ok_or_else(|| anyhow::anyhow!("Topic is required"))?;
    let title = options.title.as_ref().ok_or_else(|| anyhow::anyhow!("Title is required"))?;
    
    // Load config
    let config = load_config()?;
    
    // Check if topic exists
    let topic_config = config.content.topics.get(topic)
        .ok_or_else(|| anyhow::anyhow!("Topic not found: {}", topic))?;
    
    // Create content directory
    let content_dir = PathBuf::from(&config.content.base_dir)
        .join(&topic_config.directory)
        .join(slug);
    
    if content_dir.exists() {
        return Err(anyhow::anyhow!("Content already exists: {}", slug));
    }
    
    create_dir_all(&content_dir)?;
    
    // Create content file
    let default_template = String::from("default");
    let template_name = options.template.as_ref().unwrap_or(&default_template);
    let mut template = common_templates::load_template(template_name)?;
    
    // Create frontmatter
    let topics = vec![topic.clone()];
    
    let frontmatter = Frontmatter {
        title: title.clone(),
        published: Some(chrono::Local::now().format("%Y-%m-%d").to_string()),
        updated: Some(chrono::Local::now().format("%Y-%m-%d").to_string()),
        slug: Some(slug.clone()),
        tagline: options.description.clone(),
        tags: options.tags.clone(),
        topics: Some(topics),
        draft: options.draft,
        featured_image: None,
    };
    
    // Convert frontmatter to YAML
    let frontmatter_yaml = serde_yaml::to_string(&frontmatter)?;
    
    // Create content with frontmatter
    let template_content = template.get_content()?;
    let content = format!("---\n{}---\n\n{}", frontmatter_yaml, template_content);
    
    // Write content to file
    let content_file = content_dir.join("index.md");
    write_file(&content_file, &content)?;
    
    Ok(content_file)
}

/// List available templates
///
/// This function lists all available templates.
///
/// # Returns
///
/// Returns a list of templates
///
/// # Errors
///
/// Returns an error if the templates cannot be listed
pub fn list_templates() -> Result<Vec<common_templates::Template>> {
    Ok(common_templates::list_templates()?)
}

/// Get available topics
///
/// This function lists all available topics.
///
/// # Returns
///
/// Returns a list of topics
///
/// # Errors
///
/// Returns an error if the topics cannot be listed
pub fn get_available_topics() -> Result<Vec<(String, TopicConfig)>> {
    let config = load_config()?;
    
    let topics: Vec<(String, TopicConfig)> = config.content.topics
        .iter()
        .map(|(key, config)| (key.clone(), config.clone()))
        .collect();
    
    Ok(topics)
}

/// Create a new template
///
/// This function creates a new template.
///
/// # Parameters
///
/// * `name` - Template name
/// * `content_type` - Content type
/// * `content` - Template content
///
/// # Returns
///
/// Returns the created template
///
/// # Errors
///
/// Returns an error if the template cannot be created
pub fn create_template(name: &str, content_type: &str, content: &str) -> Result<common_templates::Template> {
    Ok(common_templates::create_template(name, content_type, content)?)
}

#[cfg(test)]
mod tests {
    use super::*;
    use common_test_utils::{TestFixture, mocks::{MockFileSystem, MockConfigLoader, MockTemplateLoader}};
    use std::collections::HashMap;
    use std::fs;
    use std::path::Path;

    /// Test creating content with valid options
    #[test]
    fn test_create_content_success() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create content options
        let options = ContentOptions {
            title: "Test Article".to_string(),
            topic: "blog".to_string(),
            tagline: "A test article".to_string(),
            tags: "test,article".to_string(),
            content_type: "article".to_string(),
            draft: false,
            template: None,
            introduction: None,
        };
        
        // Create content
        let content_path = create_content(options).unwrap();
        
        // Verify content was created
        assert!(Path::new(&content_path).exists());
        
        // Verify content has expected structure
        let content = fs::read_to_string(content_path).unwrap();
        assert!(content.contains("title: \"Test Article\""));
        assert!(content.contains("tagline: \"A test article\""));
        assert!(content.contains("tags:"));
        assert!(content.contains("\"test\","));
        assert!(content.contains("\"article\","));
    }
    
    /// Test creating content with invalid topic
    #[test]
    fn test_create_content_invalid_topic() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create content options with invalid topic
        let options = ContentOptions {
            title: "Test Article".to_string(),
            topic: "invalid-topic".to_string(),
            tagline: "A test article".to_string(),
            tags: "test,article".to_string(),
            content_type: "article".to_string(),
            draft: false,
            template: None,
            introduction: None,
        };
        
        // Attempt to create content
        let result = create_content(options);
        
        // Verify error
        assert!(result.is_err());
        let err = result.unwrap_err().to_string();
        assert!(err.contains("Invalid topic"));
        assert!(err.contains("invalid-topic"));
    }
    
    /// Test creating content with draft flag
    #[test]
    fn test_create_content_draft() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create content options with draft flag
        let options = ContentOptions {
            title: "Draft Article".to_string(),
            topic: "blog".to_string(),
            tagline: "A draft article".to_string(),
            tags: "draft".to_string(),
            content_type: "article".to_string(),
            draft: true,
            template: None,
            introduction: None,
        };
        
        // Create content
        let content_path = create_content(options).unwrap();
        
        // Verify content was created
        assert!(Path::new(&content_path).exists());
        
        // Verify content has draft flag
        let content = fs::read_to_string(content_path).unwrap();
        assert!(content.contains("draft: true"));
        assert!(content.contains("date: DRAFT"));
    }
    
    /// Test creating content with custom template
    #[test]
    fn test_create_content_custom_template() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create a custom template
        let template_name = "custom-template";
        let template_content = "---\ntitle: \"{{title}}\"\ntagline: \"{{tagline}}\"\n---\n\n# {{title}}\n\n{{introduction}}";
        create_template(template_name, "article", template_content).unwrap();
        
        // Create content options with custom template
        let options = ContentOptions {
            title: "Custom Template Article".to_string(),
            topic: "blog".to_string(),
            tagline: "Using a custom template".to_string(),
            tags: "".to_string(),
            content_type: "article".to_string(),
            draft: false,
            template: Some(template_name.to_string()),
            introduction: Some("This is a custom introduction.".to_string()),
        };
        
        // Create content
        let content_path = create_content(options).unwrap();
        
        // Verify content was created
        assert!(Path::new(&content_path).exists());
        
        // Verify content uses custom template
        let content = fs::read_to_string(content_path).unwrap();
        assert!(content.contains("title: \"Custom Template Article\""));
        assert!(content.contains("tagline: \"Using a custom template\""));
        assert!(content.contains("# Custom Template Article"));
        assert!(content.contains("This is a custom introduction."));
    }
    
    /// Test formatting tags
    #[test]
    fn test_tag_formatting() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create content options with various tag formats
        let options = ContentOptions {
            title: "Tag Test".to_string(),
            topic: "blog".to_string(),
            tagline: "Testing tag formatting".to_string(),
            tags: "tag1, tag2,tag3 , tag4".to_string(),
            content_type: "article".to_string(),
            draft: false,
            template: None,
            introduction: None,
        };
        
        // Create content
        let content_path = create_content(options).unwrap();
        
        // Verify content was created
        assert!(Path::new(&content_path).exists());
        
        // Verify tags are formatted correctly
        let content = fs::read_to_string(content_path).unwrap();
        assert!(content.contains("\"tag1\","));
        assert!(content.contains("\"tag2\","));
        assert!(content.contains("\"tag3\","));
        assert!(content.contains("\"tag4\","));
    }
    
    /// Test getting available topics
    #[test]
    fn test_get_available_topics() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Get available topics
        let topics = get_available_topics().unwrap();
        
        // Verify topics
        assert!(!topics.is_empty());
        assert!(topics.iter().any(|(name, _)| name == "blog"));
        assert!(topics.iter().any(|(name, _)| name == "notes"));
    }
    
    /// Test listing templates
    #[test]
    fn test_list_templates() {
        // Create a test fixture
        let fixture = TestFixture::new().unwrap();
        
        // Create a custom template
        let template_name = "test-template";
        let template_content = "Test template content";
        create_template(template_name, "article", template_content).unwrap();
        
        // List templates
        let templates = list_templates().unwrap();
        
        // Verify templates
        assert!(!templates.is_empty());
        assert!(templates.iter().any(|t| t.name == template_name));
    }
} 